# syntax=docker/dockerfile:1.10.0
#
# Canonical NIXL + EFA base for Dynamo on AWS/EKS
# - CUDA 12.9, Ubuntu 24.04
# - NIXL 0.7.1 (ready to move to 0.8.0)
# - libfabric 1.21.0 to /usr/local
# - UCX v1.19.0 with EFA + GDRCopy
# - GDRCopy 2.4.1
# - EFA userspace via aws-efa-installer (no kernel)
# - aws-ofi-nccl from release tarball
# - etcd-cpp-apiv3 + your URI patch + AWS SDK C++
#
ARG BASE_IMAGE="nvcr.io/nvidia/cuda-dl-base"
ARG BASE_IMAGE_TAG="25.06-cuda12.9-devel-ubuntu24.04"

FROM ${BASE_IMAGE}:${BASE_IMAGE_TAG} AS build

ARG ARCH="x86_64"
ARG DEFAULT_PYTHON_VERSION="3.12"
ARG NPROC

# Core versions
ARG NIXL_VERSION="0.7.1"              # can bump to 0.8.0 later
ARG UCX_VERSION="v1.19.0"
ARG LIBFABRIC_VERSION="v2.3.0"
ARG LIBFABRIC_INSTALL_PATH="/usr/local"
ARG GDRCOPY_VERSION="2.4.1"
ARG AWS_OFI_NCCL_VERSION="v1.17.2"    # example: latest tested release
ARG AWS_SDK_VERSION="1.11.581"
ARG ETCD_CPP_VERSION="0.15.4"

ENV DEBIAN_FRONTEND=noninteractive \
    LANG=C.UTF-8 LC_ALL=C.UTF-8 \
    CUDA_HOME=/usr/local/cuda \
    PATH=/usr/local/cuda/bin:/usr/local/bin:${PATH}

WORKDIR /opt/build

############################
# 1. System build toolchain
############################
RUN apt-get update -y && \
    apt-get install -y --no-install-recommends \
      build-essential \
      ca-certificates \
      cmake \
      ninja-build \
      meson \
      git \
      wget \
      curl \
      pkg-config \
      libtool \
      autoconf \
      automake \
      # RDMA / EFA deps
      libibverbs-dev \
      rdma-core \
      ibverbs-utils \
      libibumad-dev \
      librdmacm-dev \
      libnuma-dev \
      hwloc \
      libhwloc-dev \
      # Python
      python${DEFAULT_PYTHON_VERSION}-dev \
      pybind11-dev \
      # TLS / HTTP / GRPC
      libssl-dev \
      zlib1g-dev \
      libcurl4-openssl-dev \
      libprotobuf-dev \
      protobuf-compiler \
      protobuf-compiler-grpc \
      libgrpc++-dev \
      libgrpc-dev \
      # misc
      libaio-dev \
      liburing-dev \
      && rm -rf /var/lib/apt/lists/*

RUN apt-get update && apt-get install -y pandoc && rm -rf /var/lib/apt/lists/*

ARG RDMA_CORE_VERSION=v51.0
RUN cd /opt/build && \
    wget https://github.com/linux-rdma/rdma-core/archive/refs/tags/${RDMA_CORE_VERSION}.tar.gz && \
    tar xzf ${RDMA_CORE_VERSION}.tar.gz && \
    cd rdma-core-* && \
    mkdir build && cd build && \
    cmake -DCMAKE_INSTALL_PREFIX=/usr/local \
          -DNO_PYVERBS=1 \
          -DNO_MAN_PAGES=1 \
          -DENABLE_STATIC=1 \
          .. && \
    make -j$(nproc) && make install && \
    ldconfig && \
    cd / && rm -rf /opt/build/rdma-core-*


#===========================================================================
# EFA Installer (without kernel modules, skip libfabric for custom build)
#===========================================================================
ARG EFA_INSTALLER_VERSION="1.43.1"

RUN cd /tmp && \
    echo "=== Installing EFA Installer (skipping libfabric for custom build) ===" && \
    curl -O https://efa-installer.amazonaws.com/aws-efa-installer-${EFA_INSTALLER_VERSION}.tar.gz && \
    tar -xf aws-efa-installer-${EFA_INSTALLER_VERSION}.tar.gz && \
    cd aws-efa-installer && \
    ./efa_installer.sh -y --skip-kmod --skip-limit-conf --enable-gdr --no-verify || true && \
    cd .. && rm -rf aws-efa-installer*

# Setup EFA library paths
RUN echo "=== Setting up EFA library paths for downstream builds ===" && \
    mkdir -p /opt/amazon/efa/lib /opt/amazon/efa/include

# Find and symlink EFA library
RUN if [ -f /usr/lib/x86_64-linux-gnu/libefa.so ]; then \
        ln -sf /usr/lib/x86_64-linux-gnu/libefa.so* /opt/amazon/efa/lib/ && \
        echo "✅ EFA library symlinked from /usr/lib/x86_64-linux-gnu/"; \
    elif [ -f /usr/lib/aarch64-linux-gnu/libefa.so ]; then \
        ln -sf /usr/lib/aarch64-linux-gnu/libefa.so* /opt/amazon/efa/lib/ && \
        echo "✅ EFA library symlinked from /usr/lib/aarch64-linux-gnu/"; \
    elif [ -f /opt/amazon/efa/lib/libefa.so ]; then \
        echo "✅ EFA library already at /opt/amazon/efa/lib/"; \
    else \
        echo "⚠️  WARNING: EFA library not found, searching..." && \
        find /usr /opt -name "libefa.so*" 2>/dev/null | head -1 | xargs -I {} dirname {} | xargs -I {} ln -sf {}/libefa.so* /opt/amazon/efa/lib/ && \
        echo "✅ EFA library linked"; \
    fi

# Symlink EFA headers
RUN if [ -d /usr/include/infiniband ]; then \
        rm -rf /opt/amazon/efa/include/infiniband && \
        ln -sfn /usr/include/infiniband /opt/amazon/efa/include/infiniband && \
        echo "✅ EFA headers symlinked from /usr/include/infiniband"; \
    fi && \
    if [ -d /usr/include/rdma ]; then \
        rm -rf /opt/amazon/efa/include/rdma && \
        ln -sfn /usr/include/rdma /opt/amazon/efa/include/rdma && \
        echo "✅ RDMA headers symlinked from /usr/include/rdma"; \
    fi
    
ENV EFA_PATH=/opt/amazon/efa

############################
# 3. GDRCopy
############################
RUN git clone --depth 1 --branch v${GDRCOPY_VERSION} https://github.com/NVIDIA/gdrcopy.git && \
    cd gdrcopy && \
    CUDA=${CUDA_HOME} make prefix=/opt/gdrcopy lib lib_install && \
    echo "/opt/gdrcopy/lib64" > /etc/ld.so.conf.d/gdrcopy.conf && \
    ldconfig && \
    cd / && rm -rf gdrcopy

ENV GDRCOPY_PATH=/opt/gdrcopy
RUN cd /opt/build && \
    wget --tries=3 --waitretry=5 \
      "https://github.com/ofiwg/libfabric/releases/download/${LIBFABRIC_VERSION}/libfabric-${LIBFABRIC_VERSION#v}.tar.bz2" \
      -O libfabric.tar.bz2 && \
    tar xjf libfabric.tar.bz2 && rm libfabric.tar.bz2 && \
    cd libfabric-* && \
    ./configure \
      --prefix=${LIBFABRIC_INSTALL_PATH} \
      --disable-verbs \
      --disable-psm3 \
      --disable-opx \
      --disable-usnic \
      --disable-rstream \
      --enable-efa \
      --with-cuda=${CUDA_HOME} \
      --enable-cuda-dlopen \
      --with-gdrcopy=${GDRCOPY_PATH} \
      --enable-gdrcopy-dlopen && \
    make -j${NPROC:-$(nproc)} && make install && \
    echo "${LIBFABRIC_INSTALL_PATH}/lib" > /etc/ld.so.conf.d/libfabric.conf && \
    ldconfig && \
    cd / && rm -rf /opt/build/libfabric-*


# CRITICAL: Build libfabric from source to /usr/local (not /opt/amazon/efa)
# This is the key fix for NIXL segfault issue
RUN wget --tries=3 --waitretry=5 --timeout=30 --read-timeout=60 \
    "https://github.com/ofiwg/libfabric/releases/download/${LIBFABRIC_VERSION}/libfabric-${LIBFABRIC_VERSION#v}.tar.bz2" \
    -O /opt/build/libfabric.tar.bz2 && \
    cd /opt/build && \
    tar xjf libfabric.tar.bz2 && \
    rm libfabric.tar.bz2 && \
    cd libfabric-* && \
    ./configure \
        --prefix="${LIBFABRIC_INSTALL_PATH}" \
        --disable-verbs \
        --disable-psm3 \
        --disable-opx \
        --disable-usnic \
        --disable-rstream \
        --enable-efa \
        --with-cuda=${CUDA_HOME} \
        --enable-cuda-dlopen \
        --with-gdrcopy=/opt/gdrcopy \
        --enable-gdrcopy-dlopen && \
    make -j${NPROC:-$(nproc)} && \
    make install && \
    ldconfig && \
    cd .. && rm -rf libfabric-* && \
    echo "✅ libfabric ${LIBFABRIC_VERSION} installed to ${LIBFABRIC_INSTALL_PATH}"

# Verify libfabric installation
RUN fi_info -p efa || echo "⚠️ Warning: EFA provider not available (may need hardware)"

############################
# 5. UCX v1.19 with EFA+GDRCopy
############################
RUN cd /opt/build && \
    git clone https://github.com/openucx/ucx.git && \
    cd ucx && \
    git checkout ${UCX_VERSION} && \
    ./autogen.sh && \
    ./configure \
      --prefix=/usr/local/ucx \
      --enable-shared \
      --disable-static \
      --disable-doxygen-doc \
      --enable-optimizations \
      --enable-cma \
      --enable-devel-headers \
      --enable-mt \
      --with-cuda=${CUDA_HOME} \
      --with-gdrcopy=/opt/gdrcopy \
      --with-verbs=/opt/amazon/efa \
      --with-dm \
      --with-efa=/opt/amazon/efa && \
    make -j${NPROC:-$(nproc)} && make install-strip && \
    echo "/usr/local/ucx/lib" > /etc/ld.so.conf.d/ucx.conf && \
    echo "/usr/local/ucx/lib/ucx" >> /etc/ld.so.conf.d/ucx.conf && \
    ldconfig && \
    cd / && rm -rf /opt/build/ucx

ENV UCX_PATH=/usr/local/ucx

############################
# 6. Python
############################
# Install Python and pip
RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    python-is-python3 \
    && rm -rf /var/lib/apt/lists/*

ENV PIP_BREAK_SYSTEM_PACKAGES=1

# Install Python packages
RUN pip install --upgrade \
    meson meson-python pybind11 patchelf \
    pyyaml click tabulate auditwheel tomlkit
    
############################
# 7. etcd-cpp-apiv3 + your URI patch + AWS SDK
############################
COPY etcd-uri-fix.patch /tmp/etcd-fix/

# Install cpprestsdk dependency
RUN apt-get update && apt-get install -y \
    libcpprest-dev \
    && rm -rf /var/lib/apt/lists/*

    
# Build etcd-cpp-apiv3
RUN git clone --depth 1 -b v${ETCD_CPP_VERSION} https://github.com/etcd-cpp-apiv3/etcd-cpp-apiv3.git && \
    cd etcd-cpp-apiv3 && \
    sed -i '/^find_dependency(cpprestsdk)$/d' etcd-cpp-api-config.in.cmake && \
    patch -p1 < /tmp/etcd-fix/etcd-uri-fix.patch && \
    mkdir build && cd build && \
    cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local && \
    make -j${NPROC:-$(nproc)} && make install && \
    cd / && rm -rf etcd-cpp-apiv3

# Set the environment variable permanently
ENV ETCD_CPP_API_DISABLE_URI_VALIDATION=1

# Add documentation
RUN echo '#!/bin/bash' > /usr/local/bin/nixlbench-test && \
    echo 'echo "Testing nixlbench with ETCD fix..."' >> /usr/local/bin/nixlbench-test && \
    echo 'echo "ETCD_CPP_API_DISABLE_URI_VALIDATION=$ETCD_CPP_API_DISABLE_URI_VALIDATION"' >> /usr/local/bin/nixlbench-test && \
    echo 'if strings /usr/local/lib/libetcd-cpp-api-core.so | grep -q ETCD_CPP_API_DISABLE_URI_VALIDATION; then' >> /usr/local/bin/nixlbench-test && \
    echo '    echo "✅ Fix is applied - nixlbench should work"' >> /usr/local/bin/nixlbench-test && \
    echo 'else' >> /usr/local/bin/nixlbench-test && \
    echo '    echo "❌ Fix not found - nixlbench may fail"' >> /usr/local/bin/nixlbench-test && \
    echo 'fi' >> /usr/local/bin/nixlbench-test && \
    chmod +x /usr/local/bin/nixlbench-test

############################
# 7a. AWS SDK C++ (only S3 component)
############################    
RUN git clone --recurse-submodules --depth 1 --shallow-submodules \
        https://github.com/aws/aws-sdk-cpp.git --branch ${AWS_SDK_VERSION} && \
    mkdir aws_sdk_build && cd aws_sdk_build && \
    cmake ../aws-sdk-cpp/ \
        -DCMAKE_BUILD_TYPE=Release \
        -DBUILD_ONLY="s3" \
        -DENABLE_TESTING=OFF \
        -DCMAKE_INSTALL_PREFIX=/usr/local && \
    make -j${NPROC:-$(nproc)} && make install && \
    cd / && rm -rf aws-sdk-cpp aws_sdk_build \
    ldconfig && \
    echo "✅ AWS SDK C++ (S3 only) installed"


############################
# 8. NIXL 0.7.1 build + wheel
########################
# Build gusli (NVIDIA storage library)
RUN git clone https://github.com/nvidia/gusli.git && \
    cd gusli && \
    make all BUILD_RELEASE=1 BUILD_FOR_UNITEST=0 VERBOSE=1 ALLOW_USE_URING=0 && \
    cd .. && \
    echo "✅ gusli built"

##############################################################################
# Rust Toolchain (Required for NIXL Rust bindings)
##############################################################################

ARG RUSTUP_VERSION="1.28.1"
ARG RUST_TOOLCHAIN="1.86.0"

ENV RUSTUP_HOME=/usr/local/rustup \
    CARGO_HOME=/usr/local/cargo \
    PATH=/usr/local/cargo/bin:$PATH \
    RUSTARCH=${ARCH}-unknown-linux-gnu

RUN echo "=== Installing rustup ${RUSTUP_VERSION} and Rust toolchain ${RUST_TOOLCHAIN} ===" && \
    cd /tmp && \
    wget -q "https://static.rust-lang.org/rustup/archive/${RUSTUP_VERSION}/${RUSTARCH}/rustup-init" && \
    chmod +x rustup-init && \
    ./rustup-init -y --no-modify-path --profile minimal --default-toolchain ${RUST_TOOLCHAIN} && \
    rm rustup-init && \
    chmod -R a+w ${RUSTUP_HOME} ${CARGO_HOME} && \
    rustup default ${RUST_TOOLCHAIN} && \
    rustup toolchain list && \
    rustc --version && \
    cargo --version && \
    echo "✅ Rust toolchain ${RUST_TOOLCHAIN} installed"

##############################################################################
# Clone / patch NIXL and build C++ core (unchanged from what you had)
##############################################################################

WORKDIR /workspace/nixl
RUN git clone --depth 1 --branch ${NIXL_VERSION} \
    https://github.com/ai-dynamo/nixl.git /workspace/nixl
    
WORKDIR /workspace/nixl

RUN sed -i 's/<< event.event_type()/<< static_cast<int>(event.event_type())/' \
    src/core/nixl_listener.cpp && \
    sed -i 's/static_cast<int>(event.event_type()) == etcd::Event::EventType::DELETE_/event.event_type() == etcd::Event::EventType::DELETE_/' \
    src/core/nixl_listener.cpp

ENV NIXL_PREFIX=/usr/local/nixl \
    NIXL_LIB_DIR=/usr/local/nixl/lib/${ARCH}-linux-gnu \
    NIXL_PLUGIN_DIR=/usr/local/nixl/lib/${ARCH}-linux-gnu/plugins \
    LD_LIBRARY_PATH=/usr/local/lib:${LIBFABRIC_INSTALL_PATH}/lib:${LD_LIBRARY_PATH}

RUN rm -rf build && \
    mkdir build && \
    meson setup \
        -Dlibfabric_path=${LIBFABRIC_INSTALL_PATH} \
        build/ \
        --prefix=${NIXL_PREFIX} && \
    cd build && \
    ninja -j${NPROC:-$(nproc)} && \
    ninja install && \
    echo "✅ NIXL built with libfabric_path=${LIBFABRIC_INSTALL_PATH}"

RUN echo "${NIXL_LIB_DIR}" > /etc/ld.so.conf.d/nixl.conf && \
    echo "${NIXL_PLUGIN_DIR}" >> /etc/ld.so.conf.d/nixl.conf && \
    ldconfig

##############################################################################
# libclang + Rust bindings (FIX)
##############################################################################

# Install clang + libclang
RUN apt-get update && \
    apt-get install -y --no-install-recommends clang libclang-dev && \
    rm -rf /var/lib/apt/lists/*


# Tell bindgen where libclang.so lives
ENV LIBCLANG_PATH=/usr/lib/llvm-18/lib

# Now build Rust bindings
RUN cd src/bindings/rust && \
    cargo build --release --locked && \
    echo "✅ NIXL Rust bindings built"


##############################################################################
# Python bindings from source (CUDA 12)
##############################################################################
# After NIXL C++ + Rust build
WORKDIR /workspace/nixl

# Build + install CUDA-12 NIXL wheel from this source
RUN python3.12 -m pip install --no-cache-dir \
      meson meson-python pybind11 tomlkit && \
    python3.12 -m pip install --no-cache-dir .

# (Optional but recommended) install meta nixl stub aligned to your version
# so that "import nixl" works as expected
RUN python3.12 -m pip install --no-cache-dir "nixl==0.7.1"

# Sanity check – one-line import
RUN python3.12 -c 'import importlib.metadata as im, nixl, sys; \
print("Python:", sys.version); \
print("✅ NIXL imported:", nixl); \
print("  dist nixl:     ", im.version("nixl")); \
print("  dist nixl-cu12:", im.version("nixl-cu12"))'


##############################################################################
# Optional: Build nixlbench
##############################################################################
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        libgflags-dev && \
    rm -rf /var/lib/apt/lists/*


ENV NIXL_SRC_DIR=/workspace/nixl

RUN echo "=== Building nixlbench ===" && \
    cd ${NIXL_SRC_DIR}/benchmark/nixlbench && \
    rm -rf build && mkdir build && \
    meson setup build/ \
        --prefix=/usr/local \
        -Dnixl_path=/usr/local/nixl \
        -Dcudapath_inc=/usr/local/cuda/include \
        -Dcudapath_lib=/usr/local/cuda/lib64 \
        -Detcd_inc_path=/usr/local/include \
        -Detcd_lib_path=/usr/local/lib && \
    cd build && \
    ninja -j${NPROC:-$(nproc)} && \
    ninja install && \
    echo "✅ nixlbench installed"

#===========================================================================
#  NCCL - NVIDIA Collective Communications Library
#===========================================================================
ARG INSTALL_NCCL="1"

RUN if [ "${INSTALL_NCCL}" = "1" ]; then \
        echo "=== Building NCCL v${NCCL_VERSION} for SM${CUDA_ARCH} ===" && \
        cd /tmp && \
        git clone --depth 1 --branch v${NCCL_VERSION} https://github.com/NVIDIA/nccl.git && \
        cd nccl && \
        make -j${NPROC} src.build \
            CUDA_HOME=${CUDA_HOME} \
            NVCC_GENCODE="-gencode=arch=compute_${CUDA_ARCH},code=sm_${CUDA_ARCH}" && \
        make install PREFIX=/usr/local && \
        echo "/usr/local/lib" > /etc/ld.so.conf.d/nccl.conf && \
        ldconfig && \
        echo "✅ NCCL ${NCCL_VERSION} installed"; \
        cd / && rm -rf /tmp/nccl; \
    else \
        echo "⏭️ Skipping NCCL build (INSTALL_NCCL=0)"; \
    fi

##############################################################################
# 9. aws-ofi-nccl
##############################################################################

ARG AWS_OFI_NCCL_VERSION="v1.17.1"  # or v1.17.0, or whichever tag you want

RUN cd /opt/build && \
    echo "=== Building aws-ofi-nccl ${AWS_OFI_NCCL_VERSION} from git ===" && \
    git clone --depth 1 --branch ${AWS_OFI_NCCL_VERSION} https://github.com/aws/aws-ofi-nccl.git aws-ofi-nccl && \
    cd aws-ofi-nccl && \
    ./autogen.sh && \
    ./configure \
        --prefix=/opt/aws-ofi-nccl \
        --with-libfabric=/usr/local \
        --with-cuda=${CUDA_HOME} && \
    make -j${NPROC:-$(nproc)} && \
    make install && \
    echo "/opt/aws-ofi-nccl/lib" > /etc/ld.so.conf.d/aws-ofi-nccl.conf && \
    ldconfig && \
    cd / && rm -rf /opt/build/aws-ofi-nccl*



